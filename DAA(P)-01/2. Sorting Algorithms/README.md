📁 SelectionSortDemo.m
* Sorts an unsorted array using the Selection Sort algorithm.

* Repeatedly finds the minimum element and swaps it into place.

* Input: [64, 25, 12, 22, 11]

* Output: Sorted array.

* Demonstrates a basic sorting technique with O(n²) time complexity.

  ![2](https://github.com/user-attachments/assets/bd1c2252-bb14-47f9-a9d1-b973b8008a8b)
  

|-----------------------------------------------------------------------|

📁 *BubbleSortDemo.m*

-Implements the Bubble Sort algorithm to sort an array.

-Input: [64, 34, 25, 12, 22, 11, 90]

-Compares adjacent elements and swaps if out of order.

-Time complexity: O(n²)

Outputs the sorted array.

|-----------------------------------------------------------------------|

📁 *InsertionSortDemo.m*

-Implements the Insertion Sort algorithm for sorting an array.

-Input: [5, 4, 10, 1, 6, 2]

-Inserts each element into its correct position by shifting larger elements.

-Time complexity: O(n²) worst case, O(n) best case.

-Outputs the sorted array.

![1](https://github.com/user-attachments/assets/184e482a-04f2-4d33-a443-d374c066e4c8)

|-----------------------------------------------------------------------|

Merge Sort & Quick Sort

This document includes two popular sorting algorithm implementations in MATLAB: Merge Sort and Quick Sort. Both algorithms are recursive and used to sort arrays in ascending order.

🔹 1. Merge Sort
Merge Sort follows the Divide and Conquer strategy by dividing the array into halves, recursively sorting each half, and then merging them


![MERGE SORT](https://github.com/user-attachments/assets/e6bdabfb-e93f-4300-a562-e765a5f9463f)

🔹 2. Quick Sort
Quick Sort also uses the Divide and Conquer approach. It selects a pivot, partitions the array into elements less than, equal to, and greater than the pivot, and recursively sorts the partitions.

![quick sort](https://github.com/user-attachments/assets/278110f1-cd90-4a30-96e8-86475b129af5)





